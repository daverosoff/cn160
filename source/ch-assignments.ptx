<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="sec-assignments" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Assignments</title>
  <section xml:id="assignments-day00">
    <title>Problems for Monday, Jan 8</title>
    <p>
      Make sure you can solve all of these problems. Similar ones will appear
      on the midterm. As always in courses at this level, <q>solve</q> means
      to give complete supporting reasoning or justification, not just the answer.
      In this case you should include the details of your calculation, however
      you do it.
    </p>
    <exercises xml:id="exercises-day00">
      <exercise>
        <introduction>
          <p>
            For each problem below, interpret the summands as binary-encoded integers
            and find the sum without converting the summands to decimal.
            Express all your answers in binary, and for each problem,
            show a complete record of your reasoning. This could be a collection of
            <m>1 \to 2</m>
            machines as in the videos we saw in class, a pencil-and-paper addition with
            carries, or anything else that shows me how you came up with your answer.
          </p>
        </introduction>
        <task>
          <statement>
            <p>Add the following binary numbers: <m>1011 + 1101</m></p>
          </statement>
          <answer>
            <p>
              11000.
            </p>
          </answer>
        </task>
        <task>
          <statement>
            <p>Perform the binary addition: <m>11100 + 1011</m></p>
          </statement>
          <answer>
            <p>
              100111.
            </p>
          </answer>
        </task>
        <task>
          <statement>
            <p>Add the binary numbers: <m>10010 + 1101</m></p>
          </statement>
          <answer>
            <p>
              11111.
            </p>
          </answer>
        </task>
        <task>
          <statement>
            <p>Compute the sum: <m>1111 + 101</m></p>
          </statement>
        </task>
        <task>
          <statement>
            <p>Perform binary addition: <m>101010 + 11011</m></p>
          </statement>
        </task>
        <task>
          <statement>
            <p>Add the binary values: <m>1111 + 111</m></p>
          </statement>
        </task>
        <task>
          <statement>
            <p>Compute the sum of: <m>10101 + 110</m></p>
          </statement>
        </task>
        <task>
          <statement>
            <p>Add the binary numbers: <m>110110 + 1011</m></p>
          </statement>
        </task>
        <task>
          <statement>
            <p>Perform binary addition: <m>1111 + 1001</m></p>
          </statement>
        </task>
        <task>
          <statement>
            <p>Add the binary values: <m>101010 + 110</m></p>
          </statement>
        </task>
      </exercise>
      <exercise>
        <introduction>
          <p>
            For each problem below, interpret the summands as hexadecimal-encoded integers
            and find the sum without converting the summands to decimal. (You are allowed
            to convert them to binary, but I don't necessarily recommend it.)
            Express all your answers in hex, and for each problem,
            show a complete record of your reasoning. This could be a collection of
            <m>1 \to 2</m> or <m>1 \to 16</m>
            machines as in the videos we saw in class, a pencil-and-paper addition with
            carries, or anything else that shows me how you came up with your answer.
          </p>
        </introduction>
        <task>
          <statement>
            <p>Add the hexadecimal values: <m>C_{16} + 7_{16}</m></p>
          </statement>
          <answer>
            <p>
              <m>13_{16}</m>
            </p>
          </answer>
        </task>
        <task>
          <statement>
            <p>Perform the sum: <m>F2_{16} + 4_{16}</m></p>
          </statement>
          <answer>
            <p>
              <m>F6_{16}</m>
            </p>
          </answer>
        </task>
        <task>
          <statement>
            <p>Compute the sum: <m>1D_{16} + A_{16}</m></p>
          </statement>
          <answer>
            <p>
              <m>27_{16}</m>
            </p>
          </answer>
        </task>
        <task>
          <statement>
            <p>Perform the sum: <m>1F_{16} + A_{16}</m></p>
          </statement>
        </task>
        <task>
          <statement>
            <p>Add the hexadecimal numbers: <m>1A_{16} + 2F_{16}</m></p>
          </statement>
          <answer>
            <p>
              <m>49_{16}</m>
            </p>
          </answer>
        </task>
        <task>
          <statement>
            <p>Compute the sum: <m>3B_{16} + 4D_{16}</m></p>
          </statement>
        </task>
        <task>
          <statement>
            <p>Add the hexadecimal values: <m>A1_{16} + B2_{16}</m></p>
          </statement>
          <answer>
            <p>
              <m>153_{16}</m>
            </p>
          </answer>
        </task>
        <task>
          <statement>
            <p>Add the hexadecimal numbers: <m>2C_{16} + 13_{16}</m></p>
          </statement>
        </task>
        <task>
          <statement>
            <p>Compute the sum: <m>1AB_{16} + 2F_{16}</m></p>
          </statement>
        </task>
        <task>
          <statement>
            <p>Add the hexadecimal numbers: <m>3E_{16} + 25_{16}</m></p>
          </statement>
        </task>
        <task>
          <statement>
            <p>Add the hexadecimal numbers: <m>A7 + F9</m></p>
          </statement>
        </task>
        <task>
          <statement>
            <p>Add the hexadecimal numbers: <m>C5 + 13B</m></p>
          </statement>
        </task>
        <task>
          <statement>
            <p>Add the hexadecimal numbers: <m>124 + 17C</m></p>
          </statement>
        </task>
        <task>
          <statement>
            <p>Add the hexadecimal numbers: <m>1F3 + 1A7</m></p>
          </statement>
        </task>
        <task>
          <statement>
            <p>Add the hexadecimal numbers: <m>266 + 1C2</m></p>
          </statement>
        </task>
      </exercise>
    </exercises>
  </section>
  <section xml:id="sec-assignment-day04">
    <title>Problems for Thursday, January 11</title>
    <p>
      Work on these problems in groups of 2<ndash/>3
      while the instructor catches up on grading
      projects 00 and 01. For Python coding problems, you can save
      more files on your Pico (make sure not to overwrite <c>code.py</c>).
      Use the Serial console in Mu editor to
      see the output of your programs.
    </p>
    <exercises xml:id="exercises-day04">
      <exercise>
        <statement>
          <p>
            Write a function <c>is_even(x)</c> that takes a single integer
            argument <c>x</c> and returns <c>True</c> if the argument is even and
            <c>False</c> otherwise. You may assume that the argument is
            a nonnegative integer (do <em>not</em> validate within your
            function). You may <em>not</em> use the <c>%</c> operator.
            Only use bitwise operators and equality comparison.
          </p>
        </statement>
      </exercise>
      <exercise>
        <statement>
          <p>
            Write a function <c>bit_is_set(x, n)</c> that takes two integer
            arguments <c>x</c> and <c>n</c> and returns <c>True</c> if the
            <c>n</c>th bit of <c>x</c> is set and <c>False</c> otherwise.
            You may assume that the arguments are nonnegative integers
            (do <em>not</em> validate within your function). You may <em>not</em>
            use the <c>%</c> operator or any loops or conditionals.
            Only use bitwise operators and
            equality comparison.
          </p>
        </statement>
      </exercise>
      <exercise>
        <statement>
          <p>
            Write a function <c>set_bit(x, n)</c> that takes two integer
            arguments <c>x</c> and <c>n</c> and returns the value of <c>x</c>
            with the <c>n</c>th bit set. You may assume that the arguments are
            nonnegative integers (do <em>not</em> validate within your function).
            You may <em>not</em> use the <c>%</c> operator or any loops or
            conditionals. Only use bitwise
            operators and equality comparison.
          </p>
        </statement>
      </exercise>
      <exercise>
        <statement>
          <p>
            Write a function <c>clear_bit(x, n)</c> that takes two integer
            arguments <c>x</c> and <c>n</c> and returns the value of <c>x</c>
            with the <c>n</c>th bit cleared. You may assume that the arguments
            are nonnegative integers (do <em>not</em> validate within your
            function). You may <em>not</em> use the <c>%</c> operator or
            any loops or conditionals. Only use
            bitwise operators and equality comparison.
          </p>
        </statement>
      </exercise>
      <exercise>
        <statement>
          <p>
            Write a function <c>toggle_bit(x, n)</c> that takes two integer
            arguments <c>x</c> and <c>n</c> and returns the value of <c>x</c>
            with the <c>n</c>th bit toggled. You may assume that the arguments
            are nonnegative integers (do <em>not</em> validate within your
            function). You may <em>not</em> use the <c>%</c> operator or any
            loops or conditionals. Only use
            bitwise operators and equality comparison.
          </p>
        </statement>
      </exercise>
    </exercises>
  </section>
  <section xml:id="sec-projects">
    <title>Projects</title>
    <subsection xml:id="subsec-project-02-bitmasking">
      <title>Project 02: Bitmasking</title>
      <subsubsection xml:id="subsubsec-proj-02a">
        <title>Part A: <c>utils.py</c></title>
        <p>
          Now that we are beginning to have more than one file, it's time to
          start organizing our code. We'll do this by creating a <c>utils.py</c>
          file and moving our <c>binary_write()</c> function into it.
          The <c>code.py</c> file will be the main file, and it will import
          the <c>binary_write()</c> function from the <c>utils.py</c> directory.
        </p>
        <p>
          Use the Mu editor to open a new file on your Pico. Save and name it
          <c>utils.py</c> (put it in the top-level folder alongside
          <c>code.py</c>). Then, move (don't copy) the <c>binary_write()</c>
          function's definition into <c>utils.py</c>. You will also want to include
          any necessary import statements in <c>utils.py</c>. Now, in the
          <c>code.py</c> file, add the following line at the top:
          <cd>
            <cline>from utils import binary_write</cline>
          </cd>
          The meaning of this line is that we are importing the
          <c>binary_write()</c> function from the <c>utils.py</c> file.
          The <c>from ... import ...</c> syntax ensures that
          the short name of the function is available rather than its fully
          qualified name <c>utils.binary_write()</c>. If we do
          <c>import utils</c> instead, then we would need to
          call the function as <c>utils.binary_write()</c>.
        </p>
        <p>
          Just as we learn to separate the work of our programs into functions,
          instead of piling everything into one big main function, we should
          also separate our functions into files. This makes it easier to
          organize our code and to find things when we need to change them.
        </p>
      </subsubsection>
      <subsubsection xml:id="subsubsec-proj-02b">
        <title>Part B: Bitmasking</title>
        <p>
          Put all the function definitions from <xref ref="exercises-day04"/> into your
          <c>utils.py</c> file. You will need to add the <c>from ... import ...</c>
          statements to <c>code.py</c> to make them available.
        </p>
      </subsubsection>
      <subsubsection xml:id="subsubsec-proj-02c">
        <title>Part C: Animations</title>
        <p>
          You can create marquee-style animations by using a loop to turn on
          and off LEDs in a sequence. For example, if you have four LEDs
          connected to pins 0, 1, 2, and 3, you can create a <c>kitt</c>
          animation by turning on the first LED, then the second, then the
          third, then the fourth, then the third, then the second, then the
          first, and then repeating the process. You can use the
          <c>time.sleep()</c> function to pause between
          turning on and off the LEDs.
        </p>
        <p>
          Use the <c>binary_write()</c> function to create three different such
          animations. They shouldn't look too much alike. Each one should be enclosed
          in a function, as below. Notice there is no <c>while True</c>
          loop. We want to be able to run it only a few times, which would be
          impossible if we had an infinite loop. Do not duplicate the example as
          one of your submissions.
        </p>
        <p>
          You receive credit for Part C if you can show me three working animation
          cycles (just once through for each is fine) and the code for each uses
          <c>binary_write()</c> to turn on and off the LEDs. The <c>binary_write()</c>
          function must be imported from <c>utils.py</c>. Full credit solutions should
          make use of some of the functions from Part B.
        </p>
        <example xml:id="example-animate-kitt">
          <title>Example: <c>kitt</c> animation</title>
          <p>
            <cd>
              <cline>def animate_kitt():</cline>
              <cline>    frames = [1, 1 &lt;&lt; 1, 1 &lt;&lt; 2, 1 &lt;&lt; 3, 1 &lt;&lt; 2, 1 &lt;&lt; 1, 1] </cline>
              <cline>    for f in frames:</cline>
              <cline>        binary_write(f)</cline>
              <cline>        time.sleep(0.1)</cline>
            </cd>
          </p>
        </example>
      </subsubsection>
    </subsection>
    <subsection xml:id="subsec-proj-03">
      <title>Project 03: Buttons and Input</title>
      <introduction>
        <p>
          In this project, you'll incorporate input into your circuitry. Make sure
          Project 02 is completed before you start this one.
        </p>
        <p>
          You will need to remove one LED from your circuit to make room for the
          button. I have used its GPIO pin for the button, but you can use any pin
          you like. My concern was a readable diagram.
        </p>
        <p>
          Take care to observe that
          the button is not wired to the breadboard in the same was as the LEDs.
          The LEDs receive the high signal from GPIO through the resistor, and
          then current flows through the LED to ground. The button is wired
          so that the Pico's power rail (make sure this is connected to 3.3V
          on pin 36, not 5V on pin 40 or pin 39) is connected to one leg
          of the button, and the other leg is connected to GPIO.
        </p>
        <p>
          When the button is open (not pressed), no current flows through the
          button (it will be connected to ground through the Pico's internal
          <em>pull-down resistor</em>). When the button is closed (pressed),
          current flows from the power rail through the button to GPIO, pulling
          the GPIO input high. Your code will allow the Pico to detect this
          high voltage and trigger an action.
        </p>
      </introduction>
      <subsubsection xml:id="subsubsec-proj03-a">
        <title>Part A</title>
        <p>
          Wire your button to the breadboard as shown in the diagram below.
          <em>Make sure the power rails (red) are connected to 3.3V only!
            The 5V main power lines will destroy your Pico!</em>
        </p>
        <figure xml:id="figure-pico-with-button-bb">
          <caption>Pico with button for input.</caption>
          <image source="7-led-pico-with-button_bb_fix.png" width="30%">
            <shortdescription>
              The button is wired to the bottom three rows.
            </shortdescription>
          </image>
        </figure>
        <p>
          Then you will need to make some changes in how the pins are initialized.
          Your button pin (GPIO 16 in my diagram) will need to be configured
          as an input. Because we didn't connect the button to ground, we need
          to tell the Pico to use the internal pull-down resistor. This will
          ensure that the input is low when the button is not pressed. The code
          below shows how to do this.
          <cd>
            <cline>import board</cline>
            <cline>import digitalio</cline>
            <cline>import time</cline>
            <cline>from utils import binary_write</cline>
            <cline></cline>
            <cline>LED_PINS_SETUP = [board.GP16, board.GP17, board.GP18, board.GP19,</cline>
            <cline>                  board.GP20, board.GP21, board.GP22, board.GP26]</cline>
            <cline>PINS = [None] * 8</cline>
            <cline>for i, led_pin in enumerate(LED_PINS_SETUP):</cline>
            <cline>    PINS[i] = digitalio.DigitalInOut(led_pin)</cline>
            <cline>    PINS[i].direction = digitalio.Direction.OUTPUT</cline>
            <cline>    if i == 0:</cline>
            <cline>        PINS[i].switch_to_input(pull=digitalio.Pull.DOWN)</cline>
            <cline>    PINS[i].value = False</cline>
            <cline></cline>
            <cline>button = PINS[0]</cline>
            <cline>leds = PINS[1:]</cline>
          </cd>
          Without the internal pull-down resistor, the input would be <em>floating</em>
          when the button is not pressed. This means that it would be neither high
          nor low, and it would be impossible to tell whether the button was pressed
          or not. The internal pull-down resistor ensures that the input is low
          when the button is not pressed. Without this software solution,
          we would need to add a physical resistor to the circuit connecting the
          button to ground. The internal pull-down resistor is a convenient
          alternative and they are ubiquitous in microcontrollers.
        </p>
      </subsubsection>
      <subsubsection xml:id="subsubsec-proj03-b">
        <title>Part B</title>
        <p>
          The buttons are built so that they connect across the vertical groove
          running down the middle of the breadboard. When the button is connected,
          it electrically connects the two sides of the groove. When the button
          is pressed, both pins on the left side of the groove are connected to
          both pins on the right side of the groove.
        </p>
        <p>
          Make sure all your Project 02 code is safe somewhere (in another file,
          not <c>code.py</c>, on your Pico or your laptop) and then add this code
          to your <c>code.py</c> file:
          <cd>
            <cline>while True:</cline>
            <cline>    if button.value:</cline>
            <cline>        print("Hello sailor!")</cline>
            <cline>        time.sleep(0.5)</cline>
          </cd>
          In the Serial pane, you should see the output when you press the button.
          When you have succeeded, play with the delay time in the call to <c>time.sleep()</c>.
          What happens if you make it too short? What happens if you make it too long?
          Discuss with the people in your group.
        </p>
        <p>
          I will visit each group and check the group off together. Don't move on to
          part C until you are checked off. Instead, work on HW 1.
        </p>
      </subsubsection>
      <subsubsection xml:id="subsubsec-proj03-c">
        <title>Part C</title>
        <p>
          The difficulty with using buttons for input is that the Pico has to be listening for
          the button press. If the Pico is busy doing something else, it won't be able to
          respond to the button press. This is why we used the <c>time.sleep()</c> function
          in the example above.
        </p>
        <p>
          Try to adapt your animation code so that your Pico does the following on reset:
          <ol marker="i)">
            <li>
              <p>
                Display a short <q>ready</q> sequence, like flashing all the LEDs
                on and off three times.
              </p>
            </li>
            <li>
              <p>
                Wait for the button to be pressed.
              </p>
            </li>
            <li>
              <p>
                Display the next animation three times.
              </p>
            </li>
            <li>
              <p>
                Go to step 2.
              </p>
            </li>
          </ol>
          If you press the button while the animation is running, what happens?
          Is that what you expected, or what a typical user would expect? Discuss
          with the people in your group.
        </p>
      </subsubsection>
    </subsection>
  </section>
  <section xml:id="sec-homework">
    <title>Homework</title>
    <subsection xml:id="subsec-hw1">
      <title>Homework 1</title>
      <p>You are free to talk with others about the problems, but all the work
        you submit must be completely your own.</p>
      <exercises>
        <exercise>
          <introduction>
            <p>
              Let <m>X</m> and <m>Y</m> be unsigned 2-bit integers,
              and write <m>X = x_1 x_0</m> and <m>Y = y_1 y_0</m>. For
              example, if <m>x_1 = 1</m> and <m>x_0 = 0</m>, then
              <m>X = 2</m>. Similarly, if <m>y_1 = y_0 = 1</m>, then
              <m>Y = 3</m>. In this problem, think of <m>x_0</m>,
              <m>x_1</m>, <m>y_0</m>, and <m>y_1</m> as inputs to a
              digital circuit.
            </p>
          </introduction>
          <task>
            <statement>
              <p>
                Write a boolean expression (using AND, OR, NOT operations
                on the input variables <m>x_0</m>,
              <m>x_1</m>, <m>y_0</m>, and <m>y_1</m>) for the condition
              <m>X \gt Y</m>. (So, for example, if <m>X = 2</m> and <m>Y = 3</m>,
              then the formula should evaluate to FALSE.)
              </p>
            </statement>
          </task>
          <task>
            <statement>
              <p>
                Write a truth table for your formula.
              </p>
            </statement>
          </task>
          <task>
            <statement>
              <p>
                Using the theory of minterms and maxterms, implement your
                formula as a digital circuit
                and save it in Logisim with filename
                <c>prob01.circ</c>.
              </p>
            </statement>
          </task>
        </exercise>
        <exercise>
          <statement>
          <p>
            In this exercise, you will design a logic circuit in Logisim
            to drive two 7-segment displays from a 4-bit input. We will use
            2's complement arithmetic to handle negative numbers and create
            a circuit that can display any integer in the range <m>-8</m>
            to <m>+7</m>. In a later exercise you combine these with adders
            to create a circuit that can add two 4-bit signed integers and display
            the result.
          </p>
          <p>
            Recall that in 2's complement arithmetic on 4-bit integers,
            bit patterns <c>0000</c> through <c>0111</c> represent the
            integers <m>0</m> through <m>7</m>, and bit patterns
            <c>1000</c> through <c>1111</c> represent the integers
            <m>-8</m> through <m>-1</m>. The bit pattern <c>1000</c>
            represents <m>-8</m>, <c>1001</c> represents <m>-7</m>,
            and so on up to <c>1111</c> representing <m>-1</m>.
          </p>
          <p>
            As we saw in class, there are two advantages of this system
            over the more obvious sign-magnitude system (where the leading
            bit simply acts like a minus sign). First, there is only one
            representation of zero, and second, the circuit for addition
            is exactly the same as for unsigned integers. You will verify
            this during the course of this exercise.
          </p>
          <p>
            <xref ref="figure-7-seg-decoder-circuit"/> shows a
            7-segment display circuit in Logisim, with
            a 3-bit input <m>X = x_2 x_1 x_0</m> connected to a <q>7-segment
            decoder</q> that drives the display. <em>
              The decoder is a subcircuit
              you will design and implement using truth tables and minterms and
              maxterms.
            </em> The decoder has 7 outputs, <m>A</m> through <m>G</m>,
            that individually drive the segments of the display. The display
            has 8 pins, numbered 0 through 7, that are connected to the
            decoder outputs.
          </p>
          <sidebyside widths="25% 40%" valign="bottom">
            <figure xml:id="figure-7-seg-display-pin-labels">
              <caption>Pin labels.</caption>
              <image source="7-seg-display-with-pin-labels.png">
                <description>(for accessibility)</description>
              </image>
            </figure>
            <figure xml:id="figure-7-seg-display-segment-labels">
              <caption>Segment labels.</caption>
              <image source="7-seg-display-with-segment-labels.png">
                <description>(for accessibility)</description>
              </image>
            </figure>
          </sidebyside>
          <figure xml:id="figure-7-seg-decoder-circuit">
            <caption>The completed decoder.</caption>
            <image width="50%" source="octal-decoder-unsigned.png">
              <description>(for accessibility)</description>
            </image>
          </figure>
          <p>
            The outputs of your decoder should correspond to the labeled
            segments in <xref ref="figure-7-seg-display-segment-labels"/>.
            The decoder should be designed so that it decodes the binary
            word <m>x_2 x_1 x_0</m> and shows the value on the display.
          </p>
          <p>
            That is, when <m>x_2 = x_1 = x_0</m>, the input is
            <m>X = 0</m>,  and the display shows <m>0</m>; when
            <m>x_2 = x_1 = 0</m> and <m>x_0 = 1</m>, the input is
            <m>X = 1</m>, and the display shows <m>1</m>; and so on.
            The completed circuit should look like
            <xref ref="figure-7-seg-decoder-circuit"/>.
          </p>
          <p>
            Save your work in a file named <c>prob02.circ</c>.
          </p>
        </statement>
      </exercise>
      <exercise>
        <statement>
          <p>
            In a new Logisim file, build another decoder, this time with
            a 4-bit input <m>X = x_3 x_2 x_1 x_0</m> and 8 single-bit
            outputs. This decoder should also go in a subcircuit, named
            <c>TWOSCOMP</c>. In the main circuit, connect a 4-bit input
            pin to your decoder and connect the outputs to two 7-segment
            displays. Your task is to design the decoder so that it
            displays the 2's complement representation of the input
            integer.
          </p>
          <p>
            For example, if the input is <m>X = 0111</m>, then the
            decoder should display <m>7</m>. If the input is <m>X = 1000</m>,
            then the decoder should display <m>-8</m>. If the input is
            <m>X = 1111</m>, then the decoder should display <m>-1</m>.
            The decoder should display all the integers in the range
            <m>-8</m> to <m>7</m>, as illustrated in
            <xref ref="figure-twoscomp-decoder-positive"/> and
            <xref ref="figure-twoscomp-decoder-negative"/>.
          </p>
          <sidebyside widths="37% 37%" valign="bottom">
            <figure xml:id="figure-twoscomp-decoder-positive">
              <caption>Positive integers.</caption>
              <image source="twoscomp-decoder-positive.png">
                <description>(for accessibility)</description>
              </image>
            </figure>
            <figure xml:id="figure-twoscomp-decoder-negative">
              <caption>Negative integers.</caption>
              <image source="twoscomp-decoder-negative.png">
                <description>(for accessibility)</description>
              </image>
            </figure>
          </sidebyside>
          <p>
            Save your work in a file named <c>prob03.circ</c>.
          </p>
        </statement>
      </exercise>
      <exercise>
        <statement>
          <p>
            Construct a circuit using three of your <c>TWOSCOMP</c>
            controllers from the previous problem and six 7-segment
            display to show a 2's complement addition. You will need
            the 4-bit adder subcircuit from Project 04 (on Canvas). The
            adder subcircuit here is the small box with the <m>+</m>
            sign. You can use the built-in <c>Adder</c> component
            from the <c>Arithmetic</c> menu, but only single-bit adders:
            implement your own 4-bit ripple carry adder.
          </p>
          <p>
            The completed circuit should resemble <xref ref="figure-signed-adder4"/>.
          </p>
          <figure xml:id="figure-signed-adder4">
            <caption>2's complement adder.</caption>
            <image width="55%" source="signed-adder4.png">
              <description>(for accessibility)</description>
            </image>
          </figure>
          <p>
            Save your work in a file named <c>prob04.circ</c>.
          </p>
        </statement>
      </exercise>
      <exercise>
        <statement>
          <p>
            If you Poke in (hand tool) various values in your circuit from
            the previous problem, you will notice the result is not always
            correct. Chapter 3 in Plantz discusses fixed-width addition
            errors in detail. In this problem, your task is to add an
            error-detecting circuit to your 4-bit signed adder from the
            previous problem.
          </p>
          <p>
            The error-detecting circuit should have three inputs
            and a single output that is <m>1</m> if the result of the addition
            is incorrect and <m>0</m> otherwise. The error-detecting
            circuit should be implemented as a subcircuit named
            <c>ERROR</c>. The completed circuit should resemble
            <xref ref="figure-signed-adder4-error"/>.
          </p>
          <figure xml:id="figure-signed-adder4-error">
            <caption>2's complement adder with error detection.</caption>
            <image width="55%" source="signed-adder4-with-error.png">
              <description>(for accessibility)</description>
            </image>
          </figure>
          <p>
            Save your work in a file named <c>prob05.circ</c>.
          </p>
        </statement>
      </exercise>
    </exercises>
    </subsection>
    <subsection xml:id="subsec-hw2">
      <title>Homework 2</title>
      <p>
        You are free to talk with others about the problems, but all the work
        you submit must be completely your own.
      </p>
      <exercises xml:id="exercises-hw2">
        <exercise>
          <statement>
            <p>
              In this problem, you will design a 2-bit (clocked) register with
              JK flip-flops. The register should have two inputs,
              <m>X_0</m> and <m>X_1</m>, and two outputs, <m>Q_0</m>
              and <m>Q_1</m>. When the clock input is <m>0</m>, the
              register should hold its current value. When the clock
              input changes from <m>0</m> to <m>1</m>, the register
              should load the values of <m>X_0</m> and <m>X_1</m>
              (meaning those should be the values of <m>Q_0</m> and
              <m>Q_1</m> after the clock changes from <m>0</m> to
              <m>1</m>).
            </p>
            <p>
              The state diagram is easier to describe than it is to draw.
              There are four states, 0, 1, 2, and 3. When the input is
              <m>X</m>, the next state is <m>X</m>, regardless of the
              current state. Here is a table summarizing the situation:
            </p>
            <tabular halign="center">

              <row header="yes" bottom="minor">
                <cell><m>X</m></cell>
                <cell>current state</cell>
                <cell>next state</cell>
              </row>
              <row>
                <cell>0</cell>
                <cell>0</cell>
                <cell>0</cell>
              </row>
              <row>
                <cell>0</cell>
                <cell>1</cell>
                <cell>0</cell>
              </row>
              <row>
                <cell>0</cell>
                <cell>2</cell>
                <cell>0</cell>
              </row>
              <row bottom="minor">
                <cell>0</cell>
                <cell>3</cell>
                <cell>0</cell>
              </row>
              <row>
                <cell>1</cell>
                <cell>0</cell>
                <cell>1</cell>
              </row>
              <row>
                <cell>1</cell>
                <cell>1</cell>
                <cell>1</cell>
              </row>
              <row>
                <cell>1</cell>
                <cell>2</cell>
                <cell>1</cell>
              </row>
              <row bottom="minor">
                <cell>1</cell>
                <cell>3</cell>
                <cell>1</cell>
              </row>
              <row>
                <cell>2</cell>
                <cell>0</cell>
                <cell>2</cell>
              </row>
              <row>
                <cell>2</cell>
                <cell>1</cell>
                <cell>2</cell>
              </row>
              <row>
                <cell>2</cell>
                <cell>2</cell>
                <cell>2</cell>
              </row>
              <row bottom="minor">
                <cell>2</cell>
                <cell>3</cell>
                <cell>2</cell>
              </row>
              <row>
                <cell>3</cell>
                <cell>0</cell>
                <cell>3</cell>
              </row>
              <row>
                <cell>3</cell>
                <cell>1</cell>
                <cell>3</cell>
              </row>
              <row>
                <cell>3</cell>
                <cell>2</cell>
                <cell>3</cell>
              </row>
              <row>
                <cell>3</cell>
                <cell>3</cell>
                <cell>3</cell>
              </row>
            </tabular>
            <p>
              As in class, you should organize your calculation and
              design in the following steps.
            </p>
            <ol marker="1.">
              <li>
                <p>
                  Encode the states and inputs as binary numbers.
                </p>
              </li>
              <li>
                <p>
                  Rewrite the state transition table using your
                  binary encoding.
                </p>
              </li>
              <li>
                <p>
                  The current state is the value of the output.
                  Each output bit will be connected to a flip-flop.
                  Add appropriate columns to the state transition
                  table for the flip-flops.
                </p>
              </li>
              <li>
                <p>
                  Fill in the new columns based on the transition
                  diagrams for the flip-flops you selected. We used
                  JK flip-flops in class and it is fine to stick with
                  those. Using anything else will require a bit more
                  creativity and engineering problem-solving from you.
                  Not every flip-flop is appropriate for every circuit.
                </p>
              </li>
              <li>
                <p>
                  Create K-maps for each of the flip-flop columns you
                  added.
                </p>
              </li>
              <li>
                <p>
                  Write the boolean expressions for the next state
                  of each flip-flop.
                </p>
              </li>
              <li>
                <p>
                  Implement the circuit in Logisim and save it in
                  a file named <c>prob01.circ</c>.
                </p>
              </li>
            </ol>
            <!-- <figure xml:id="figure-hw2-ex1-register-state-dia">
              <caption>Fix</caption> -->
              <!-- <image width="50%">
                <latex-image>
                  \begin{tikzpicture}[on grid, scale=0.5]
                    \node[state] (q00) {$00$};
                    \node[state, below right=of q00] (q11) {$11$};
                    \node[state, above right=of q11] (q01) {$01$};
                    \node[state, below=of q11] (q10) {$10$};
                    \path[->]
                      (q00) edge[loop left] node {$00$} (q00)
                      edge[bend left] node {$01$} (q01)
                      edge[bend left] node {$10$} (q10)
                      edge[bend left] node {$11$} (q11)
                      (q01) edge[loop right] node {$01$} (q01)
                      edge[bend left] node {$00$} (q00)
                      edge[bend left] node {$10$} (q10)
                      edge[bend left] node {$11$} (q11)
                      (q10) edge[loop left] node {$10$} (q10)
                      edge[bend left, bend angle=80] node {$00$} (q00)
                      edge[bend left] node {$11$} (q11)
                      edge[bend left] node {$01$} (q01)
                      (q11) edge[loop right] node {$11$} (q11)
                      edge[bend left] node {$00$} (q00)
                      edge[bend left] node {$01$} (q01)
                      edge[bend left] node {$10$} (q10)
                    ;
                  \end{tikzpicture}
                </latex-image>
              </image> -->
            <!-- </figure> -->
          </statement>
        </exercise>
        <exercise>
          <statement>
            <p>
              Design a clocked circuit with one (non-clock) input bit.
              There will be one bit of output. Draw the
              state diagram according to the following:
              <ol marker="A.">
                <li>
                  <p>
                    When three or more consecutive inputs have been 0, the output should be 1.
                  </p>
                </li>
                <li>
                  <p>
                    When three or more consecutive inputs have been 1, the output should be 1.
                  </p>
                </li>
                <li>
                  <p>
                    Otherwise, the output should be 0.
                  </p>
                </li>
              </ol>
              As in problem 1, you can use any flip-flops you like.
              Use the same procedure outlined in the
              previous problem.
            </p>
          </statement>
          <hint>
            <p>
              You can do this with five states. The circuit will start in
              state A and never return to it. Assume the output is 0 when
              we are in state A (because we haven't yet had a chance to
              see three consecutive inputs). Note that you may find a
              more efficient (fewer states) solution; I only worked out
              one possibility.
            </p>
          </hint>
        </exercise>
      </exercises>
    </subsection>
  </section>
</chapter>
